# faq.md  
*Structure Language Protocol (SLP) — Frequently Asked Questions*

---

## 1. What is SLP in one sentence?

SLP is a **deterministic structural protocol** for representing, interpreting, resolving, and executing structural graphs in a way that is consistent across humans, machines, and AI systems.

---

## 2. How is SLP different from JSON, YAML, XML, or GraphQL?

Those formats describe **data**.  
SLP describes **structure + behavior**.

SLP includes:

- a syntax  
- a grammar  
- an interpreter  
- a resolution engine  
- a runtime execution model  

It is closer to a *protocol* than a data format.

---

## 3. Is SLP a programming language?

No.  
SLP does not execute instructions or control flow.  
It defines **structure**, not computation.

You can think of it as:

- a structural language  
- a graph protocol  
- a deterministic representation of relationships  

---

## 4. Why does SLP need an interpreter and runtime?

Because structure is not static.

SLP supports:

- propagation  
- inheritance  
- closure transitions  
- dimensional alignment  
- conflict resolution  
- event‑driven updates  

These require a **runtime**, not just parsing.

---

## 5. What problems does SLP solve?

SLP solves the problem of **structural inconsistency** across:

- documents  
- systems  
- tools  
- AI models  
- organizations  
- knowledge graphs  

It provides a **single, deterministic way** to represent and evolve structure.

---

## 6. Why is determinism so important?

Because without determinism:

- two interpreters produce different graphs  
- two AIs reason differently about the same structure  
- two humans misunderstand the same document  
- propagation becomes unpredictable  

SLP guarantees that **same input → same output** everywhere.

---

## 7. What is the difference between RSG and FRSG?

**RSG (Resolved Structural Graph)**  
Output of the interpreter.  
Structure is parsed and normalized, but not yet executed.

**FRSG (Fully Resolved Structural Graph)**  
Output of the resolution engine.  
All propagation, inheritance, closure, and dimension rules applied.

---

## 8. Do I need to understand closure or dimension to use SLP?

No.  
You can start with:
NodeA NodeB NodeA -> NodeB

Closure, dimension, tension, polarity, and other structural attributes are **optional** and only needed for advanced modeling.

---

## 9. What is the SLP runtime?

The runtime is the engine that:

- processes events  
- applies updates  
- propagates changes  
- resolves cycles  
- maintains atomicity  
- ensures consistency  

It is the “live” structural environment.

---

## 10. Can SLP be used with AI systems?

Yes — SLP is **AI‑native**.

AI systems can:

- read snapshots  
- propose updates  
- reason over structure  
- generate SLP documents  
- interact through the API  

But they cannot:

- mutate memory directly  
- bypass validation  
- override runtime rules  

---

## 11. Is SLP domain‑specific?

No.  
SLP is domain‑agnostic.

It can represent:

- cognitive models  
- organizational structures  
- knowledge graphs  
- system architectures  
- multi‑agent protocols  
- conceptual frameworks  
- simulations  

Anything that has **structure**.

---

## 12. How big can an SLP graph get?

SLP is designed for:

- small conceptual models  
- medium‑scale system diagrams  
- large‑scale structural graphs  

The protocol itself has no size limit.  
Implementations may impose practical limits.

---

## 13. Does SLP support custom attributes or relation types?

Yes.

You can define:

- new attributes  
- new relation types  
- new block semantics  

SLP is extensible as long as extensions remain:

- deterministic  
- unambiguous  
- structurally consistent  

---

## 14. How does SLP ensure interoperability?

Through:

- strict syntax  
- strict grammar  
- deterministic interpreter  
- deterministic resolution engine  
- canonical formatter  
- validator + linter  
- interoperability test suite  

Multiple implementations must produce identical results.

---

## 15. Can SLP replace UML, ER diagrams, or knowledge graphs?

SLP is not a replacement — it is a **foundation**.

You can build:

- UML  
- ER models  
- ontologies  
- knowledge graphs  
- system diagrams  

on top of SLP because SLP provides the **structural substrate**.

---

## 16. Is SLP stable?

Yes.  
The core syntax and grammar are stable.  
Extensions and advanced features evolve through versioned specifications.

---

## 17. What license does SLP use?

The license is chosen **after** the full protocol is complete.  
SLP is designed to support:

- open licenses  
- dual licenses  
- protocol‑specific licenses  
- anti‑enclosure models  

The final choice is made at release time.

---

## 18. Where should I start?

If you're new:

1. Read `overview.md`  
2. Follow `quickstart.md`  
3. Explore the examples  
4. Use the CLI to validate and interpret  
5. Read the design philosophy  

SLP is intentionally minimal — you can learn it quickly.

---

## 19. Who maintains SLP?

SLP is designed to be stewarded by:

- a foundation  
- a standards body  
- or a protocol governance group  

The goal is long‑term stability and neutrality.

---

## 20. Summary

SLP is:

- simple to learn  
- powerful in practice  
- deterministic  
- interoperable  
- extensible  
- AI‑native  

It provides a universal way to represent and evolve structure — for humans, machines, and AI systems.

